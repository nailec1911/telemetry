# Telemetry Viewer

This project provides a **graphical viewer** for telemetry data, allowing users to load, and visualize time-series telemetry logs. It is implemented using **Python and PyQtGraph** for fast, interactive plotting.

## Features

- Load a telemetry file and display its time-series data
- Select which variable (series) to visualize
- Zoom and pan on the graph using the mouse

## Installation
### 1. Prerequisites

Ensure you have Python 3.8+ installed.

### 2. Install Required Dependencies

Run the following command to install required packages:
```bash
pip install -r requirements.txt
```

This will install:
- PyQt6 → For GUI components
- PyQtGraph → For fast plotting
- pandas → For data handling
- numpy → For efficient numerical operations

## Usage

To launch the telemetry viewer, use:

```bash
./telemetry_viewer <file name>
```

If no file is provided, you can open a file manually using the GUI.
you can also use ``./telemetry_viewer --help`` to see the ``USAGE``:
```
$> ./telemetry_viewer --help
usage: telemetry_viewer [-h] [FILE]

A visualizer for telemetry files.

positional arguments:
  FILE        File to analyze (optional).

options:
  -h, --help  show this help message and exit
```

## File Format

The viewer expects a telemetry file generated by the telemetry recording system. The format is structured as series of timestamped values, supporting:
- Double (float) values
- String values (not plotted, but parsed)

## Library Choices

### 1️. GUI Framework: PyQt6 + PyQtGraph

Why PyQt6?
- Easy implementation
- Provides a flexible GUI
- Supports dialogs, menus, and interactivity

Why PyQtGraph?
- Optimized for real-time plotting
- Faster than Matplotlib for large datasets

Moreover, Pyqt and PyqtGraph offer many features and customization option, which makes them perfect for future improvements.

### 2. Data Handling: Pandas + NumPy
Why Pandas?
- Handles time-series data efficiently
- Provides built-in sorting & filtering
  
Why NumPy?
- Fast numerical processing
- Easily converts to formats usable by PyQtGraph

### 3. Command-Line Argument Handling: argparse

Why argparse?
- Easy to implement
- Has a lot of possibilities if we need to add features
- Standardized approach for handling command-line inputs in Python.

## Implementation choices

### Why Object-Oriented Programming (OOP)?

Object-Oriented Programming (OOP) was chosen to ensure modularity, scalability, and maintainability in the telemetry viewer.
The biggest advantage of OOP are :

1. Code Reusability & Maintainability
    - The ``Serie`` class can be reused or extended for additional features (supporting new data types like vectors).
    - The GUI (``TelemetryGUI`` class) is separate from the data-handling logic, following the Single Responsibility Principle (SRP).
    - This allows for easier improvements without modifying the entire codebase (it is also easier to test).

2. Scalability
    - More features (real-time data streaming, data combination ..) can be easily added without breaking existing functionality.
    - If a new type of telemetry data is introduced, a class can be changed without affecting other parts of the system.

### Encapsulation of Telemetry Data : ``Serie()`` and ``TelemetryValues()``

The Serie class encapsulates each telemetry series, keeping data structured and self-contained.

Each instance of Serie stores:
- ``name: str`` → The name of the series (ex: "battery_level")
- ``unit: str`` → The measurement unit (ex: "V", "km"...)
- ``value_type: type`` → The type of the serie (str, int ...)
- ``values: pd.Series`` → A pandas Series mapping timestamps to values

the ``TelemetryValues`` class groups all Serie objects, store some generals value (log name, timestamp) and handle key operations such as:
- Registering new series when parsing the telemetry file.
- Mapping values to the correct series based on their unique ID.
- Get series by type so the GUI doesn't have to sort them.

The series are stored in a dictionnay, to allow an easy access to each serie with its id.

### The class ``Parser()``

The Parser class is responsible for reading and decoding binary telemetry files. It ensures that data is correctly interpreted and structured while handling errors.

The file is read in one go and then stored as bytes. Then the bytes are consumed in order, elements by elements, in the same order that the file is written.

The library ``struct`` is used to parse the bytes into variables. It is useful because the telemetry file is written in ``C++``, and struct allows to directly map C++ primitive types to Python. This ensures:
- Unpacking of multiple values at once.
- Simple format definitions, making it easy to maintain and extend.

By defining format strings ('=Qd' for a timestamp and double value), we can precisely control how data is extracted.

#### Possible improvements :
- Streaming Parsing: Instead of loading the entire file into memory, we could read and process data in chunks, making it more efficient for large files.
- Logging errors: Adding logging for easier debugging of corrupted data.

## General Improvements

1. Error handling :
   - Custom error class and more precise error informations ensure an easier maintainability
2. More features: 
    - Add support for streaming real-time telemetry
    - Improve UI to show multiple graph at once
    - Add more serie types (point, vector, map ...)
3. Testing:
    - Unit tests and functional test (unsing ``pytest``) would be a great plus, particularly on the Parser,  which is the most error-prone part of the program.
    - It ensure that everything work correctly and that there is no regression if we add features.
- 
